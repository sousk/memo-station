require "rss/maker"
module ForRSS
  include ActionView::Helpers::TextHelper
  include ActionView::Helpers::TagHelper
  include ActionView::Helpers::SanitizeHelper
  
  include ApplicationHelper

  def rss
    # rss = RSS::Maker.make("1.0") do |maker|
    #   maker.channel.about = url_for(:action => "rss")
    #   maker.channel.title = APPLICATION_TITLE
    #   maker.channel.link = url_for(:action => "index")
    #   maker.channel.description = "#{APPLICATION_TITLE} feeds generated by RSS::Maker"
    #   Article.find(:all, :order => "modified_at desc", :limit => 30).each do |article|
    #     item = maker.items.new_item
    #     item.title = article.subject
    #     item.date = article.modified_at || Time.now
    #     item.link = url_for(:action => "show", :id => article)
    #     item.description = truncate(strip_tags(article.body).to_a.map{|e|e.strip}.join(" "), 80)
    #     item.content_encoded = html_escape(article_simple_format(article.body))
    #     item.dc_creator = article.user ? article.user.login : 'anonymouse'
    #   end
    # end
    headers["Content-Type"] = "application/xml; charset=UTF-8"
    render :text => "<msg>not implemented yet</msg>", :layout => false
  end
end

class ArticlesController < ApplicationController
  DEFAULT_PER_PAGE = 30
  
  before_filter :login_required, :except => [:index, :show]
  
  extend ActionView::Helpers::SanitizeHelper::ClassMethods
  include ForRSS
  
  def index
    @articles = Article.paginate :page => params['page'], 
      :per_page => params[:limit] || DEFAULT_PER_PAGE, :order => 'updated_at DESC'
  end
  
  def new
    @article = Article.new
    [:subject, :body, :url].each do |name|
      @article[name] = params[name].to_s.strip
    end
    render :action => :edit
  end
  
  def update
    if params[:id].blank?
      @article = Article.new :modified_at => Time.now
      status = "投稿"
    else
      status = "更新"
      @article = Article.find(params[:id])
    end
    @before_article = @article.dup
    @article.attributes = params[:article]
    @article.user ||= current_user
    Article.transaction {
      unless @article.save
        render :action => "edit"
        return
      end
    }
    # Mailman.deliver_article_update(self, Time.now, :article => {:before => @before_article, :after => @article})
    flash[:notice] = "#{status}しました。"
    flash[:notice_duration] = 0.8
    redirect_to :action => "index"
  end
  
  def show
    @article = Article.get params[:id], current_user
    
    last = viewed_timestamps[params[:id]]
    if last.nil? || Time.now > 1.day.since(last)
      viewed_timestamps[params[:id]] = Time.now
      if logged_in? && (@article.user.id != current_user.id || ENV["RAILS_ENV"] == "development")
        # article.user.user_info.karma += 1
        # article.user.user_info.save!
      end
    end
  end
  
  def edit
    @article = Article.find(params[:id])
  end
  
  def bookmark
    @articles = Article.paginate :page => params['page'], 
      :conditions => "url is not null",
      :per_page => params[:limit] || DEFAULT_PER_PAGE, :order => 'url_access_at DESC'
    render :action => "index"
  end
  
  def most_viewed
    case params[:period]
    when "today"
      @page_title = "今日"
      before_time = Time.now.beginning_of_day
    when "week"
      @page_title = "1週間でいちばん"
      before_time = 1.week.ago
    when "month"
      @page_title = "1ヶ月間でいちばん"
      before_time = 1.month.ago
    when "all"
      @page_title = "全体でいちばん"
      before_time = 1.years.ago
    else
      @page_title = "今日"
      before_time = Time.now.beginning_of_day
    end
    
    @articles = Article.most_viewed_with_paginate before_time, params[:page], DEFAULT_PER_PAGE
    render :action => 'index'
  end
  
  private
  def viewed_timestamps
    session[:article_viewed_timestamp] ||= {}
  end
end
